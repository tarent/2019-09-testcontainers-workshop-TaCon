package de.tarent.youtrainserver.controller;

import de.tarent.youtrainserver.entity.Course;
import de.tarent.youtrainserver.repository.CourseRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.togglz.core.manager.FeatureManager;
import org.togglz.core.util.NamedFeature;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.Collections;
import java.util.Optional;
import java.util.stream.Collectors;

import static java.math.BigDecimal.valueOf;
import static java.util.stream.StreamSupport.stream;
import static org.springframework.http.HttpStatus.OK;

/**
 * The REST API controller for course.
 *
 * @author Mark Vz
 */
@RestController
@RequestMapping(path = "/courses")
public class CourseController {

    public static final NamedFeature FEATURE_SALE = new NamedFeature("SALE");

    @Autowired
    // This means to get the bean called courseRepository which is auto-generated by Spring, we will use it to handle the data
    private CourseRepository courseRepository;

    @Autowired
    private FeatureManager featureManager;

    @GetMapping
    public @ResponseBody
    Iterable<Course> findAllWithSimpleFullTextSearch(@RequestParam(value = "q", required = false) String searchText, @RequestParam(value = "begin", required = false) String begin, @RequestParam(value = "end", required = false) String end) {
        // TODO: combine fulltext and date range searches via Streaming API
        final Iterable<Course> result;
        if (searchText == null) {
            if (begin != null && end != null) {
                Timestamp beginDate = Timestamp.valueOf(String.format("%s 00:00:00", begin));
                Timestamp endDate = Timestamp.valueOf(String.format("%s 00:00:00", end));
                result = courseRepository.findAllInRange(beginDate, endDate);
            } else {
                result = courseRepository.findAll();
            }
        } else {
            result = courseRepository.findAllLikeSearch(searchText);
        }
        return stream(result.spliterator(), false)
                .map(this::applyDiscount)
                .collect(Collectors.toList());
    }

    @GetMapping(path = "{id}")
    public @ResponseBody
    ResponseEntity<Course> findOneById(@PathVariable("id") Integer id) {
        return courseRepository.findById(id)
                .map(this::applyDiscount)
                .map(course -> new ResponseEntity<>(course, OK))
                .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public @ResponseBody
    Course createNew(@RequestBody Course payload) {
        final Course course = new Course();
        course.setTitle(payload.getTitle());
        course.setDescription(payload.getDescription());
        course.setTeacher(payload.getTeacher());
        course.setPrice(payload.getPrice());

        if (payload.getCourseDates() != null) {
            course.setCourseDates(payload.getCourseDates());
        } else {
            course.setCourseDates(Collections.emptyList());
        }

        Course savedCourse = courseRepository.save(course);
        return applyDiscount(savedCourse);
    }

    @PatchMapping(path = "{id}")
    public @ResponseBody
    Optional<Course> updateOne(@PathVariable("id") Integer id, @RequestBody Course payload) {
        Optional<Course> courseFromRepo = courseRepository.findById(id);

        return courseFromRepo.map( course -> {
            course.setTitle(payload.getTitle());
            course.setDescription(payload.getDescription());
            course.setTeacher(payload.getTeacher());
            course.setPrice(payload.getPrice());
            course.getCourseDates().clear();
            course.getCourseDates().addAll(payload.getCourseDates());
            return courseRepository.save(course);
        }).map(this::applyDiscount);
    }

    @DeleteMapping(path = "{id}")
    public @ResponseBody
    Boolean deleteById(@PathVariable("id") Integer id) {
        courseRepository.deleteById(id);
        return true;
    }

    private Course applyDiscount(Course course) {
        if (featureManager.isActive(FEATURE_SALE)) {
            BigDecimal _50_percent = valueOf(50, 2);
            course.setPrice(course.getPrice().multiply(_50_percent));
        }
        return course;
    }
}
